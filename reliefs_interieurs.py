# -*- coding: utf-8 -*-
"""Reliefs_Interieurs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1beePeahFQQ76yS_LnZqJSbxEdNYQyU8v

# üèîÔ∏è Reliefs Int√©rieurs
## G√©n√©ration d‚Äôun paysage 3D √† partir du bruit de Perlin

Dans ce projet, nous transformons un simple bruit coh√©rent en un relief 3D.
Le bruit devient une montagne, une vall√©e, un territoire imaginaire.

Objectif :
- cr√©er un heightmap coh√©rent
- le visualiser en 3D
- ajouter une lumi√®re directionnelle pour r√©v√©ler les ombres
- produire une image expressive, presque picturale
"""

!pip install noise

import numpy as np
import matplotlib.pyplot as plt
from noise import pnoise2
from mpl_toolkits.mplot3d import Axes3D

def generate_heightmap(width, height, scale=100, octaves=6, persistence=0.5, lacunarity=2.0):
    """G√©n√®re un heightmap bas√© sur du bruit de Perlin."""
    hm = np.zeros((height, width))

    for y in range(height):
        for x in range(width):
            nx = x / scale
            ny = y / scale
            hm[y][x] = pnoise2(nx, ny,
                               octaves=octaves,
                               persistence=persistence,
                               lacunarity=lacunarity)

    # Normalisation entre 0 et 1
    hm = (hm - hm.min()) / (hm.max() - hm.min())
    return hm

def apply_lighting(heightmap, azimuth=45, altitude=45):
    """Calcule une carte d'ombres bas√©e sur la lumi√®re directionnelle."""
    # Conversion en radians
    az = np.radians(azimuth)
    alt = np.radians(altitude)

    # Gradients
    gy, gx = np.gradient(heightmap)

    # Normale du terrain
    normal_x = -gx
    normal_y = -gy
    normal_z = 1.0

    # Normalisation
    norm = np.sqrt(normal_x**2 + normal_y**2 + normal_z**2)
    normal_x /= norm
    normal_y /= norm
    normal_z /= norm

    # Direction de la lumi√®re
    lx = np.cos(alt) * np.cos(az)
    ly = np.cos(alt) * np.sin(az)
    lz = np.sin(alt)

    # Intensit√© de la lumi√®re
    shading = normal_x * lx + normal_y * ly + normal_z * lz
    shading = np.clip(shading, 0, 1)

    return shading

width, height = 300, 300

hm = generate_heightmap(width, height)
shading = apply_lighting(hm, azimuth=60, altitude=45)

X, Y = np.meshgrid(np.arange(width), np.arange(height))

fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(111, projection='3d')

ax.plot_surface(X, Y, hm, facecolors=plt.cm.terrain(shading),
                rstride=1, cstride=1, linewidth=0, antialiased=False)

ax.set_axis_off()
plt.tight_layout()
plt.show()

plt.figure(figsize=(8, 8))
plt.imshow(hm, cmap="terrain")
plt.contour(hm, levels=12, colors="black", linewidths=0.4)
plt.axis("off")
plt.show()